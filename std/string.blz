pub struct String {
    bytes: Vec<u8>,
}

impl String {
    pub fn new() -> String {
        String {
            bytes: Vec::new(),
        }
    }
    
    pub fn with_capacity(capacity: usize) -> String {
        String {
            bytes: Vec::with_capacity(capacity),
        }
    }
    
    pub fn from(s: &str) -> String {
        String {
            bytes: Vec::from(s.as_bytes()),
        }
    }
    
    pub fn from_utf8(bytes: Vec<u8>) -> Result<String, Utf8Error> {
        if validate_utf8(&bytes) {
            Ok(String { bytes })
        } else {
            Err(Utf8Error)
        }
    }
    
    pub fn from_utf8_unchecked(bytes: Vec<u8>) -> String {
        String { bytes }
    }
    
    pub fn len(&self) -> usize {
        self.bytes.len()
    }
    
    pub fn is_empty(&self) -> bool {
        self.bytes.is_empty()
    }
    
    pub fn capacity(&self) -> usize {
        self.bytes.capacity()
    }
    
    pub fn clear(&mut self) {
        self.bytes.clear();
    }
    
    pub fn push(&mut self, ch: char) {
        let mut buf = [0u8; 4];
        let encoded = encode_utf8_char(ch, &mut buf);
        for &byte in encoded {
            self.bytes.push(byte);
        }
    }
    
    pub fn push_str(&mut self, s: &str) {
        for &byte in s.as_bytes() {
            self.bytes.push(byte);
        }
    }
    
    pub fn pop(&mut self) -> Option<char> {
        if self.is_empty() {
            return None;
        }
        
        let ch = self.chars().last()?;
        let char_len = ch.len_utf8();
        let new_len = self.len() - char_len;
        self.bytes.truncate(new_len);
        Some(ch)
    }
    
    pub fn remove(&mut self, idx: usize) -> char {
        let ch = self.chars().nth(idx).unwrap();
        let char_len = ch.len_utf8();
        self.bytes.remove_range(idx..idx + char_len);
        ch
    }
    
    pub fn insert(&mut self, idx: usize, ch: char) {
        let mut buf = [0u8; 4];
        let encoded = encode_utf8_char(ch, &mut buf);
        for (i, &byte) in encoded.iter().enumerate() {
            self.bytes.insert(idx + i, byte);
        }
    }
    
    pub fn insert_str(&mut self, idx: usize, s: &str) {
        for (i, &byte) in s.as_bytes().iter().enumerate() {
            self.bytes.insert(idx + i, byte);
        }
    }
    
    pub fn truncate(&mut self, new_len: usize) {
        if new_len <= self.len() {
            self.bytes.truncate(new_len);
        }
    }
    
    pub fn as_str(&self) -> &str {
        unsafe { str_from_utf8_unchecked(&self.bytes) }
    }
    
    pub fn as_bytes(&self) -> &[u8] {
        &self.bytes
    }
    
    pub fn as_mut_str(&mut self) -> &mut str {
        unsafe { str_from_utf8_unchecked_mut(&mut self.bytes) }
    }
    
    pub fn chars(&self) -> Chars {
        Chars {
            bytes: &self.bytes,
            pos: 0,
        }
    }
    
    pub fn split(&self, delimiter: char) -> Split {
        Split {
            string: self,
            delimiter,
            pos: 0,
            finished: false,
        }
    }
    
    pub fn split_whitespace(&self) -> SplitWhitespace {
        SplitWhitespace {
            string: self,
            pos: 0,
        }
    }
    
    pub fn lines(&self) -> Lines {
        Lines {
            string: self,
            pos: 0,
        }
    }
    
    pub fn trim(&self) -> &str {
        self.as_str().trim()
    }
    
    pub fn trim_start(&self) -> &str {
        self.as_str().trim_start()
    }
    
    pub fn trim_end(&self) -> &str {
        self.as_str().trim_end()
    }
    
    pub fn starts_with(&self, prefix: &str) -> bool {
        self.as_str().starts_with(prefix)
    }
    
    pub fn ends_with(&self, suffix: &str) -> bool {
        self.as_str().ends_with(suffix)
    }
    
    pub fn contains(&self, needle: &str) -> bool {
        self.as_str().contains(needle)
    }
    
    pub fn replace(&self, from: &str, to: &str) -> String {
        String::from(self.as_str().replace(from, to))
    }
    
    pub fn to_lowercase(&self) -> String {
        String::from(self.as_str().to_lowercase())
    }
    
    pub fn to_uppercase(&self) -> String {
        String::from(self.as_str().to_uppercase())
    }
}

impl Clone for String {
    fn clone(&self) -> Self {
        String {
            bytes: self.bytes.clone(),
        }
    }
}

impl PartialEq for String {
    fn eq(&self, other: &Self) -> bool {
        self.bytes == other.bytes
    }
}

impl Default for String {
    fn default() -> Self {
        String::new()
    }
}

impl Add for String {
    type Output = String;
    
    fn add(mut self, other: String) -> String {
        self.push_str(other.as_str());
        self
    }
}

pub struct Chars<'a> {
    bytes: &'a [u8],
    pos: usize,
}

impl<'a> Iterator for Chars<'a> {
    type Item = char;
    
    fn next(&mut self) -> Option<char> {
        if self.pos >= self.bytes.len() {
            return None;
        }
        
        let ch = decode_utf8_char(&self.bytes[self.pos..]);
        self.pos += ch.len_utf8();
        Some(ch)
    }
}

pub struct Split<'a> {
    string: &'a String,
    delimiter: char,
    pos: usize,
    finished: bool,
}

impl<'a> Iterator for Split<'a> {
    type Item = &'a str;
    
    fn next(&mut self) -> Option<&'a str> {
        if self.finished {
            return None;
        }
        
        let remaining = &self.string.as_str()[self.pos..];
        
        if let Some(idx) = remaining.find(self.delimiter) {
            let result = &remaining[..idx];
            self.pos += idx + self.delimiter.len_utf8();
            Some(result)
        } else {
            self.finished = true;
            Some(remaining)
        }
    }
}

pub struct SplitWhitespace<'a> {
    string: &'a String,
    pos: usize,
}

pub struct Lines<'a> {
    string: &'a String,
    pos: usize,
}

pub struct Utf8Error;
