use crate::io::{IoError};
use crate::result::Result;

pub struct TcpListener {
    fd: i32,
}

impl TcpListener {
    pub fn bind(addr: &str) -> Result<TcpListener, IoError> {
        extern "C" fn blaze_tcp_bind(ptr: *const u8, len: usize) -> i32;
        unsafe {
            let fd = blaze_tcp_bind(addr.as_ptr(), addr.len());
            if fd < 0 {
                Err(IoError::new("Failed to bind TCP listener"))
            } else {
                Ok(TcpListener { fd })
            }
        }
    }
    
    pub async fn accept(&self) -> Result<(TcpStream, String), IoError> {
        extern "C" fn blaze_tcp_accept(fd: i32, addr_buf: *mut u8, addr_len: *mut usize) -> i32;
        unsafe {
            let mut addr_buf = [0u8; 256];
            let mut addr_len = addr_buf.len();
            
            let stream_fd = blaze_tcp_accept(
                self.fd,
                addr_buf.as_mut_ptr(),
                &mut addr_len as *mut usize
            );
            
            if stream_fd < 0 {
                Err(IoError::new("Failed to accept connection"))
            } else {
                let addr = String::from_utf8_unchecked(
                    Vec::from(&addr_buf[..addr_len])
                );
                Ok((TcpStream { fd: stream_fd }, addr))
            }
        }
    }
}

impl Drop for TcpListener {
    fn drop(&mut self) {
        extern "C" fn blaze_close(fd: i32);
        unsafe {
            blaze_close(self.fd);
        }
    }
}

pub struct TcpStream {
    fd: i32,
}

impl TcpStream {
    pub async fn connect(addr: &str) -> Result<TcpStream, IoError> {
        extern "C" fn blaze_tcp_connect(ptr: *const u8, len: usize) -> i32;
        unsafe {
            let fd = blaze_tcp_connect(addr.as_ptr(), addr.len());
            if fd < 0 {
                Err(IoError::new("Failed to connect"))
            } else {
                Ok(TcpStream { fd })
            }
        }
    }
    
    pub async fn read(&mut self, buffer: &mut [u8]) -> Result<usize, IoError> {
        extern "C" fn blaze_tcp_read(fd: i32, ptr: *mut u8, len: usize) -> isize;
        unsafe {
            let bytes_read = blaze_tcp_read(self.fd, buffer.as_mut_ptr(), buffer.len());
            if bytes_read < 0 {
                Err(IoError::new("Failed to read from TCP stream"))
            } else {
                Ok(bytes_read as usize)
            }
        }
    }
    
    pub async fn write(&mut self, data: &[u8]) -> Result<usize, IoError> {
        extern "C" fn blaze_tcp_write(fd: i32, ptr: *const u8, len: usize) -> isize;
        unsafe {
            let bytes_written = blaze_tcp_write(self.fd, data.as_ptr(), data.len());
            if bytes_written < 0 {
                Err(IoError::new("Failed to write to TCP stream"))
            } else {
                Ok(bytes_written as usize)
            }
        }
    }
    
    pub fn shutdown(&self) -> Result<(), IoError> {
        extern "C" fn blaze_tcp_shutdown(fd: i32) -> i32;
        unsafe {
            let result = blaze_tcp_shutdown(self.fd);
            if result < 0 {
                Err(IoError::new("Failed to shutdown TCP stream"))
            } else {
                Ok(())
            }
        }
    }
}

impl Drop for TcpStream {
    fn drop(&mut self) {
        extern "C" fn blaze_close(fd: i32);
        unsafe {
            blaze_close(self.fd);
        }
    }
}

pub struct UdpSocket {
    fd: i32,
}

impl UdpSocket {
    pub fn bind(addr: &str) -> Result<UdpSocket, IoError> {
        extern "C" fn blaze_udp_bind(ptr: *const u8, len: usize) -> i32;
        unsafe {
            let fd = blaze_udp_bind(addr.as_ptr(), addr.len());
            if fd < 0 {
                Err(IoError::new("Failed to bind UDP socket"))
            } else {
                Ok(UdpSocket { fd })
            }
        }
    }
    
    pub async fn recv_from(&self, buffer: &mut [u8]) -> Result<(usize, String), IoError> {
        extern "C" fn blaze_udp_recv_from(
            fd: i32,
            buf: *mut u8,
            buf_len: usize,
            addr: *mut u8,
            addr_len: *mut usize
        ) -> isize;
        
        unsafe {
            let mut addr_buf = [0u8; 256];
            let mut addr_len = addr_buf.len();
            
            let bytes_read = blaze_udp_recv_from(
                self.fd,
                buffer.as_mut_ptr(),
                buffer.len(),
                addr_buf.as_mut_ptr(),
                &mut addr_len as *mut usize
            );
            
            if bytes_read < 0 {
                Err(IoError::new("Failed to receive from UDP socket"))
            } else {
                let addr = String::from_utf8_unchecked(
                    Vec::from(&addr_buf[..addr_len])
                );
                Ok((bytes_read as usize, addr))
            }
        }
    }
    
    pub async fn send_to(&self, data: &[u8], addr: &str) -> Result<usize, IoError> {
        extern "C" fn blaze_udp_send_to(
            fd: i32,
            buf: *const u8,
            buf_len: usize,
            addr: *const u8,
            addr_len: usize
        ) -> isize;
        
        unsafe {
            let bytes_sent = blaze_udp_send_to(
                self.fd,
                data.as_ptr(),
                data.len(),
                addr.as_ptr(),
                addr.len()
            );
            
            if bytes_sent < 0 {
                Err(IoError::new("Failed to send to UDP socket"))
            } else {
                Ok(bytes_sent as usize)
            }
        }
    }
}

impl Drop for UdpSocket {
    fn drop(&mut self) {
        extern "C" fn blaze_close(fd: i32);
        unsafe {
            blaze_close(self.fd);
        }
    }
}
