use crate::hash::{Hash, Hasher};
use crate::vec::Vec;
use crate::option::Option;

pub struct HashMap<K, V> {
    buckets: Vec<Vec<Entry<K, V>>>,
    len: usize,
}

struct Entry<K, V> {
    key: K,
    value: V,
    hash: u64,
}

impl<K, V> HashMap<K, V> where K: Hash + PartialEq {
    pub fn new() -> HashMap<K, V> {
        HashMap::with_capacity(16)
    }
    
    pub fn with_capacity(capacity: usize) -> HashMap<K, V> {
        let mut buckets = Vec::with_capacity(capacity);
        for _ in 0..capacity {
            buckets.push(Vec::new());
        }
        
        HashMap {
            buckets,
            len: 0,
        }
    }
    
    pub fn len(&self) -> usize {
        self.len
    }
    
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }
    
    pub fn capacity(&self) -> usize {
        self.buckets.len()
    }
    
    pub fn clear(&mut self) {
        for bucket in self.buckets.iter_mut() {
            bucket.clear();
        }
        self.len = 0;
    }
    
    pub fn insert(&mut self, key: K, value: V) -> Option<V> {
        if self.len >= self.capacity() * 3 / 4 {
            self.grow();
        }
        
        let hash = Self::hash_key(&key);
        let bucket_idx = (hash % self.capacity() as u64) as usize;
        let bucket = &mut self.buckets[bucket_idx];
        
        for entry in bucket.iter_mut() {
            if entry.hash == hash && entry.key == key {
                let old_value = replace(&mut entry.value, value);
                return Some(old_value);
            }
        }
        
        bucket.push(Entry { key, value, hash });
        self.len += 1;
        None
    }
    
    pub fn get(&self, key: &K) -> Option<&V> {
        let hash = Self::hash_key(key);
        let bucket_idx = (hash % self.capacity() as u64) as usize;
        let bucket = &self.buckets[bucket_idx];
        
        for entry in bucket.iter() {
            if entry.hash == hash && &entry.key == key {
                return Some(&entry.value);
            }
        }
        
        None
    }
    
    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {
        let hash = Self::hash_key(key);
        let bucket_idx = (hash % self.capacity() as u64) as usize;
        let bucket = &mut self.buckets[bucket_idx];
        
        for entry in bucket.iter_mut() {
            if entry.hash == hash && &entry.key == key {
                return Some(&mut entry.value);
            }
        }
        
        None
    }
    
    pub fn contains_key(&self, key: &K) -> bool {
        self.get(key).is_some()
    }
    
    pub fn remove(&mut self, key: &K) -> Option<V> {
        let hash = Self::hash_key(key);
        let bucket_idx = (hash % self.capacity() as u64) as usize;
        let bucket = &mut self.buckets[bucket_idx];
        
        for (i, entry) in bucket.iter().enumerate() {
            if entry.hash == hash && &entry.key == key {
                let entry = bucket.remove(i);
                self.len -= 1;
                return Some(entry.value);
            }
        }
        
        None
    }
    
    pub fn iter(&self) -> HashMapIter<K, V> {
        HashMapIter {
            map: self,
            bucket_idx: 0,
            entry_idx: 0,
        }
    }
    
    pub fn iter_mut(&mut self) -> HashMapIterMut<K, V> {
        HashMapIterMut {
            buckets: &mut self.buckets,
            bucket_idx: 0,
            entry_idx: 0,
        }
    }
    
    pub fn keys(&self) -> Keys<K, V> {
        Keys {
            iter: self.iter(),
        }
    }
    
    pub fn values(&self) -> Values<K, V> {
        Values {
            iter: self.iter(),
        }
    }
    
    fn hash_key(key: &K) -> u64 {
        let mut hasher = DefaultHasher::new();
        key.hash(&mut hasher);
        hasher.finish()
    }
    
    fn grow(&mut self) {
        let new_capacity = self.capacity() * 2;
        let mut new_map = HashMap::with_capacity(new_capacity);
        
        for bucket in self.buckets.iter_mut() {
            for entry in bucket.drain() {
                new_map.insert(entry.key, entry.value);
            }
        }
        
        *self = new_map;
    }
}

impl<K: Clone, V: Clone> Clone for HashMap<K, V> where K: Hash + PartialEq {
    fn clone(&self) -> Self {
        let mut new_map = HashMap::with_capacity(self.capacity());
        for (key, value) in self.iter() {
            new_map.insert(key.clone(), value.clone());
        }
        new_map
    }
}

impl<K, V> Default for HashMap<K, V> where K: Hash + PartialEq {
    fn default() -> Self {
        HashMap::new()
    }
}

pub struct HashMapIter<'a, K, V> {
    map: &'a HashMap<K, V>,
    bucket_idx: usize,
    entry_idx: usize,
}

impl<'a, K, V> Iterator for HashMapIter<'a, K, V> {
    type Item = (&'a K, &'a V);
    
    fn next(&mut self) -> Option<(&'a K, &'a V)> {
        loop {
            if self.bucket_idx >= self.map.buckets.len() {
                return None;
            }
            
            let bucket = &self.map.buckets[self.bucket_idx];
            if self.entry_idx < bucket.len() {
                let entry = &bucket[self.entry_idx];
                self.entry_idx += 1;
                return Some((&entry.key, &entry.value));
            }
            
            self.bucket_idx += 1;
            self.entry_idx = 0;
        }
    }
}

pub struct HashMapIterMut<'a, K, V> {
    buckets: &'a mut Vec<Vec<Entry<K, V>>>,
    bucket_idx: usize,
    entry_idx: usize,
}

pub struct Keys<'a, K, V> {
    iter: HashMapIter<'a, K, V>,
}

impl<'a, K, V> Iterator for Keys<'a, K, V> {
    type Item = &'a K;
    
    fn next(&mut self) -> Option<&'a K> {
        self.iter.next().map(|(k, _)| k)
    }
}

pub struct Values<'a, K, V> {
    iter: HashMapIter<'a, K, V>,
}

impl<'a, K, V> Iterator for Values<'a, K, V> {
    type Item = &'a V;
    
    fn next(&mut self) -> Option<&'a V> {
        self.iter.next().map(|(_, v)| v)
    }
}
